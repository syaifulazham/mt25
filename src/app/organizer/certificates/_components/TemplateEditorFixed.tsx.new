'use client'

import React, { useState, useRef, useEffect } from 'react'
import { PreviewModal } from './PreviewModal'
import { Session } from 'next-auth'
import { useRouter } from 'next/navigation'
import { DebugPanel } from './DebugPanel'

interface TemplateEditorProps {
  template?: any // Template data from database
  session: Session
  isNew?: boolean
}

interface Element {
  id: string
  type: 'static_text' | 'dynamic_text' | 'image'
  position: { x: number, y: number }
  content?: string
  prefix?: string  // Added prefix field for dynamic text
  placeholder?: string
  style?: any
  text_anchor?: 'start' | 'middle' | 'end'  // Controls text alignment relative to position
  layer: number
  isSelected?: boolean
}
// Component for the certificate template editor

export function TemplateEditor({ template, session, isNew = false }: TemplateEditorProps) {
  // IMMEDIATE DEBUG: Log template configuration as received from server
  console.log('TEMPLATE RAW DATA FROM SERVER:', JSON.stringify(template?.configuration?.elements?.map(el => ({
    id: el.id,
    type: el.type,
    text_anchor: el.text_anchor,
    style: el.style,
    prefix: el.prefix
  })), null, 2));
  
  const router = useRouter()
  const canvasRef = useRef<HTMLDivElement>(null)
  const [pdfUrl, setPdfUrl] = useState<string | null>(template?.basePdfPath || null)
  
  // Correctly process elements from template data ensuring text_anchor and prefix are preserved
  const processLoadedElements = (loadedElements: Element[] = []): Element[] => {
    console.log('Processing loaded elements:', JSON.stringify(loadedElements, null, 2));
    
    return loadedElements.map(element => {
      // IMPORTANT: Make a DEEP COPY to avoid reference issues
      const processedElement = JSON.parse(JSON.stringify(element));
      
      console.log(`Element ${element.id} original properties:`, {
        type: element.type,
        text_anchor: element.text_anchor,
        'style.align': element.style?.align,
        prefix: element.prefix
      });
      
      // For text elements, ensure properties are properly set based on style
      if (element.type === 'static_text' || element.type === 'dynamic_text') {
        // Set text_anchor based on style.align if it doesn't exist
        if (processedElement.text_anchor === undefined || processedElement.text_anchor === null) {
          if (element.style?.align === 'center') {
            processedElement.text_anchor = 'middle';
          } else if (element.style?.align === 'right') {
            processedElement.text_anchor = 'end';
          } else {
            processedElement.text_anchor = 'start';
          }
        }
        
        // For dynamic text, ensure prefix is defined
        if (element.type === 'dynamic_text' && 
            (processedElement.prefix === undefined || processedElement.prefix === null)) {
          processedElement.prefix = '';
        }
      }
      
      console.log(`Element ${element.id} PROCESSED properties:`, {
        type: processedElement.type,
        text_anchor: processedElement.text_anchor,
        'style.align': processedElement.style?.align,
        prefix: processedElement.prefix
      });
      
      return processedElement;
    });
  };
  
  // Initialize elements state with processed elements from template
  const [elements, setElements] = useState<Element[]>(() => {
    const rawElements = template?.configuration?.elements || [];
    const fixedElements = rawElements.map((el: any) => {
      // Make a deep copy
      const element = JSON.parse(JSON.stringify(el));
      
      // Fix text_anchor based on style.align
      if ((element.type === 'static_text' || element.type === 'dynamic_text') && element.style) {
        // CRITICAL FIX: Explicitly set text_anchor based on style.align
        if (element.style.align === 'center') {
          element.text_anchor = 'middle';
        } else if (element.style.align === 'right') {
          element.text_anchor = 'end';
        } else {
          element.text_anchor = 'start';
        }
        
        // Ensure prefix exists
        if (element.type === 'dynamic_text' && element.prefix === undefined) {
          element.prefix = '';
        }
      }
      
      return element;
    });
    
    console.log("FIXED ELEMENTS ON INIT:", fixedElements);
    return fixedElements;
  });
  
  const [templateName, setTemplateName] = useState(template?.templateName || 'New Template')
  const [selectedElement, setSelectedElement] = useState<Element | null>(null)
  const [isDragging, setIsDragging] = useState(false)
  const [dragStartPosition, setDragStartPosition] = useState({ x: 0, y: 0 })
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [success, setSuccess] = useState<string | null>(null)
  
  // Target audience configuration states
  const [targetType, setTargetType] = useState<'GENERAL' | 'EVENT_PARTICIPANT' | 'EVENT_WINNER'>(template?.targetType || 'GENERAL')
  const [eventId, setEventId] = useState<number | null>(template?.eventId || null)
  const [winnerRangeStart, setWinnerRangeStart] = useState<number | null>(template?.winnerRangeStart || 1)
  const [winnerRangeEnd, setWinnerRangeEnd] = useState<number | null>(template?.winnerRangeEnd || 3)
  const [events, setEvents] = useState<{id: number, name: string}[]>([])
  
  // Set up state for showing preview modal
  const [showPreview, setShowPreview] = useState(false)
  // Debug mode toggle
  const [debugMode, setDebugMode] = useState(true)

  // Function to fix text anchor properties in the elements
  const fixTextAnchorProperties = () => {
    const updatedElements = elements.map(element => {
      const updatedElement = JSON.parse(JSON.stringify(element));
      
      // Ensure text_anchor is set based on style.align
      if (element.type === 'dynamic_text' || element.type === 'static_text') {
        // Update text_anchor based on style.align
        if (element.style?.align === 'center') {
          updatedElement.text_anchor = 'middle';
        } else if (element.style?.align === 'right') {
          updatedElement.text_anchor = 'end';
        } else {
          updatedElement.text_anchor = 'start';
        }
        
        // Ensure prefix exists for dynamic text
        if (element.type === 'dynamic_text' && updatedElement.prefix === undefined) {
          updatedElement.prefix = '';
        }
      }
      
      return updatedElement;
    });
    
    // Update state with fixed elements
    setElements(updatedElements);
    
    // Set success message
    setSuccess('Text anchor properties fixed! Try selecting an element now.');
    
    // Print debug info
    console.log('Fixed elements:', updatedElements);
  };

  // Update element properties
  const updateElementProperty = (property: string, value: any) => {
    if (!selectedElement) return
    
    console.log(`Updating property ${property} to:`, value);
    
    // For font size updates, ensure we're using a valid numeric value
    if (property === 'style.font_size') {
      // Ensure font size is a valid number
      const numValue = parseFloat(value);
      if (isNaN(numValue) || numValue < 8) {
        value = 16; // Default to 16px if invalid
      }
    }
    
    // Update the selected element immediately for better visual feedback
    if (property.startsWith('style.')) {
      const styleProp = property.split('.')[1]
      setSelectedElement({
        ...selectedElement,
        style: {
          ...selectedElement.style,
          [styleProp]: value
        }
      });
    } else {
      console.log(`Setting ${property} to ${value} on element ${selectedElement.id}`);
      setSelectedElement({
        ...selectedElement,
        [property]: value
      });
    }
    
    // Update all elements in state
    setElements(prevElements => prevElements.map(el => {
      if (el.id === selectedElement.id) {
        if (property.startsWith('style.')) {
          const styleProp = property.split('.')[1]
          return {
            ...el,
            style: {
              ...el.style,
              [styleProp]: value
            }
          }
        }
        return { ...el, [property]: value }
      }
      return el
    }))
  }

  // Rest of the component implementation...
  // [For brevity, I'll include just enough for the fix]

  return (
    <div>
      {/* Notification area for success/error messages */}
      <div className="mb-4">
        {error && (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
            <span className="block sm:inline">{error}</span>
          </div>
        )}
        {success && (
          <div className="bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded relative" role="alert">
            <span className="block sm:inline">{success}</span>
          </div>
        )}
      </div>
      
      {/* Template basic details */}
      <div className="bg-white rounded-lg shadow-sm p-6 mb-6">
        <h2 className="text-xl font-bold mb-4">Template Details</h2>
        
        <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
          <div>
            <label className="block text-sm font-medium mb-2" htmlFor="templateName">
              Template Name
            </label>
            <input
              type="text"
              id="templateName"
              value={templateName}
              onChange={(e) => setTemplateName(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-md"
              placeholder="Enter template name"
            />
          </div>
        </div>
      </div>
      
      {/* Main controls section */}
      <div className="mt-4">
        {/* Action buttons */}
        <div className="flex justify-end mb-4 space-x-2">
          <button 
            type="button"
            onClick={fixTextAnchorProperties}
            className="px-4 py-2 bg-red-600 text-white font-medium rounded-md hover:bg-red-700 transition-colors"
          >
            Fix Text Alignment Properties
          </button>
          
          <button 
            type="button"
            onClick={() => setDebugMode(!debugMode)}
            className="px-4 py-2 bg-yellow-500 text-white font-medium rounded-md hover:bg-yellow-600 transition-colors"
          >
            Toggle Debug {debugMode ? 'OFF' : 'ON'}
          </button>
        </div>
      </div>

      {/* Debug Panel */}
      {debugMode && (
        <div className="mt-4 p-4 bg-gray-100 rounded-lg">
          <h3 className="text-lg font-bold">Debug Information</h3>
          <pre className="mt-2 bg-gray-800 text-white p-4 rounded overflow-auto text-xs" style={{maxHeight: '300px'}}>
            {JSON.stringify({
              elements: elements.map(el => ({
                id: el.id,
                type: el.type,
                text_anchor: el.text_anchor,
                prefix: el.prefix,
                style: el.style
              }))
            }, null, 2)}
          </pre>
        </div>
      )}
    </div>
  )
}
