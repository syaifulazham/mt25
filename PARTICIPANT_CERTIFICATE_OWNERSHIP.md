# Participant Certificate Ownership

## Overview
Participants should be able to manage operations within their contingent scope, including generating certificates for their contestants. This document explains how certificate ownership is tracked for participant-generated vs organizer-generated certificates.

## User Table Structure

### Two User Tables
The system has two separate user tables:

| Table | Purpose | Users | Access Level |
|-------|---------|-------|--------------|
| `user` | Organizer system | Admin, Operators | Full system access |
| `user_participant` | Participant portal | Parents, Teachers | Contingent-scoped access |

### The Challenge
The `certificate.createdBy` field has a **foreign key constraint** to the `user` table:
```sql
CONSTRAINT `fk_certificate_createdBy` 
FOREIGN KEY (`createdBy`) REFERENCES `user` (`id`)
```

This means only admin/operators can be tracked as creators using this field.

## Solution: Nullable `createdBy`

### Database Schema Change
Made `createdBy` **nullable** to support participant-generated certificates:

```sql
ALTER TABLE certificate 
MODIFY COLUMN createdBy INT NULL 
COMMENT 'References user.id (admin/operators). NULL for participant-generated certificates.';
```

**Database Migration:**
```sql
ALTER TABLE certificate 
MODIFY COLUMN createdBy INT NULL 
COMMENT 'References user.id (admin/operators). NULL for participant-generated certificates.';
```

**Prisma Schema Update:**
```prisma
model Certificate {
  // ... other fields
  createdBy      Int?   // Nullable
  creator        user?  // Optional relation
  // ... other fields
}
```

After updating schema, regenerate Prisma client:
```bash
npx prisma generate
```

### Tracking Certificate Origin

| `createdBy` Value | Generated By | Use Case |
|-------------------|--------------|----------|
| `NOT NULL` (1, 2, 3...) | Admin/Operator | Organizer-created certificates |
| `NULL` | Participant | Self-service contestant certificates |

## Implementation

### API Endpoint
`POST /api/participants/contestants/[id]/generate-certificate`

### Code Logic
```typescript
// For participant-generated certificates
const createdByUserId = null; // NULL = participant-generated

await prisma.$executeRaw`
  INSERT INTO certificate 
  (..., createdBy)
  VALUES (
    ...,
    ${createdByUserId}  -- NULL for participants
  )
`;
```

### Certificate Queries

**Find participant-generated certificates:**
```sql
SELECT * FROM certificate 
WHERE createdBy IS NULL;
```

**Find organizer-created certificates:**
```sql
SELECT c.*, u.name as creator_name, u.email as creator_email
FROM certificate c
JOIN user u ON c.createdBy = u.id
WHERE c.createdBy IS NOT NULL;
```

## Benefits

### 1. Clear Ownership Model
- `createdBy = NULL` → Participant-generated (self-service)
- `createdBy = [user_id]` → Organizer-created (admin/operator)

### 2. No Foreign Key Violations
Participants can generate certificates without needing a user table account.

### 3. Audit Trail Maintained
- Organizer actions: Tracked via `createdBy` → `user.id`
- Participant actions: Tracked via API authentication + `createdBy IS NULL` pattern

### 4. Proper Scoping
- Participants operate within their contingent scope (validated in API)
- Organizers have full system access (user table = admin privileges)

## Authentication & Authorization

### Participant Endpoints
```typescript
// Authenticate via NextAuth with user_participant table
const session = await getServerSession(authOptions);

// Validate participant has access to contestant's contingent
const contestant = await prisma.contestant.findUnique({
  where: { id: contestantId },
  include: { contingent: true }
});

// Ensure participant manages this contingent
// (API validates contingent ownership)
```

### Organizer Endpoints
```typescript
// Authenticate via NextAuth with user table
const session = await getServerSession(authOptions);

// Check role
if (!['ADMIN', 'OPERATOR'].includes(session.user.role)) {
  return unauthorized;
}

// Set createdBy from user table
const createdByUserId = parseInt(session.user.id);
```

## Migration History

### Issue
```
Error: Code 1452 - Cannot add or update a child row: 
foreign key constraint fails (certificate.createdBy → user.id)
```

### Root Cause
Participants are in `user_participant` table, but `certificate.createdBy` requires `user` table FK.

### Evolution

**v1 (Wrong):**
```typescript
// Tried to use participant user ID
const userId = parseInt(session.user.id); // user_participant.id
// FK constraint failure!
```

**v2 (Workaround):**
```typescript
// Used system admin ID
const createdByUserId = 1; // Always use admin
// Works but loses audit trail
```

**v3 (Current - Correct):**
```typescript
// Use NULL for participant-generated
const createdByUserId = null; // Clear indicator
// Proper separation of concerns
```

## Certificate Types by Creator

### Participant-Generated (createdBy = NULL)
- **Type**: GENERAL certificates
- **Template**: Latest ACTIVE GENERAL template
- **Recipient**: Contestant (participant's contingent)
- **Trigger**: Self-service via participants portal
- **Access**: Scoped to participant's contingent
- **Serial**: MT25/GEN/000001, MT25/GEN/000002...

### Organizer-Generated (createdBy = user.id)
- **Types**: NON_CONTEST_PARTICIPANT, EVENT_WINNER, etc.
- **Templates**: Any active template
- **Recipients**: Anyone (judges, staff, winners)
- **Trigger**: Manual creation by admin/operator
- **Access**: Full system access
- **Serial**: MT25/NCP/000001, MT25/WIN/000001...

## Examples

### Query 1: All Certificates with Creator Info
```sql
SELECT 
  c.id,
  c.uniqueCode,
  c.serialNumber,
  c.recipientName,
  c.recipientType,
  c.status,
  CASE 
    WHEN c.createdBy IS NULL THEN 'Participant (Self-Service)'
    ELSE CONCAT(u.name, ' (', u.role, ')')
  END as created_by_info,
  c.createdAt
FROM certificate c
LEFT JOIN user u ON c.createdBy = u.id
ORDER BY c.createdAt DESC;
```

### Query 2: Participant vs Organizer Statistics
```sql
SELECT 
  CASE 
    WHEN createdBy IS NULL THEN 'Participant-Generated'
    ELSE 'Organizer-Created'
  END as source,
  COUNT(*) as total_certificates,
  COUNT(CASE WHEN status = 'READY' THEN 1 END) as completed,
  COUNT(CASE WHEN status = 'DRAFT' THEN 1 END) as pending
FROM certificate
GROUP BY CASE WHEN createdBy IS NULL THEN 'Participant-Generated' ELSE 'Organizer-Created' END;
```

### Query 3: Find Organizer for Certificate
```sql
SELECT 
  c.uniqueCode,
  c.serialNumber,
  c.recipientName,
  u.name as organizer_name,
  u.email as organizer_email,
  u.role as organizer_role
FROM certificate c
JOIN user u ON c.createdBy = u.id
WHERE c.id = 123;
```

## API Endpoints Comparison

### Participant API
```
POST /api/participants/contestants/[id]/generate-certificate
- Auth: user_participant session
- Scope: Own contingent only
- createdBy: NULL
- Template: GENERAL only
```

### Organizer API
```
POST /api/certificates/create-non-contestant
- Auth: user session (ADMIN/OPERATOR)
- Scope: System-wide
- createdBy: user.id
- Template: Any type
```

## Best Practices

### 1. Never Mix User Tables
```typescript
// ❌ WRONG - Don't try to use participant ID for createdBy
const userId = session.user.id; // from user_participant
await insert({ createdBy: userId }); // FK violation!

// ✅ CORRECT - Use NULL for participants
const createdByUserId = null;
await insert({ createdBy: createdByUserId }); // Works!
```

### 2. Validate Contingent Access
```typescript
// Always verify participant has rights to the contingent
const contestant = await prisma.contestant.findUnique({
  where: { id: contestantId },
  include: { contingent: true }
});

// Check participant manages this contingent
if (!userManagesContingent(session.user.id, contestant.contingentId)) {
  return unauthorized;
}
```

### 3. Clear Audit Trails
```typescript
// Log participant actions separately if needed
await auditLog.create({
  action: 'CERTIFICATE_GENERATED',
  userType: 'PARTICIPANT',
  userId: session.user.id, // user_participant.id
  certificateId: certificate.id,
  contingentId: contestant.contingentId
});
```

## Future Enhancements

### Option 1: Add Participant Tracking Column
```sql
ALTER TABLE certificate 
ADD COLUMN createdByParticipantId INT NULL,
ADD CONSTRAINT fk_certificate_createdByParticipant
  FOREIGN KEY (createdByParticipantId) 
  REFERENCES user_participant(id);
```

Then:
```typescript
const createdByUserId = null; // Organizer
const createdByParticipantId = session.user.id; // Participant
```

### Option 2: Unified Audit Table
```sql
CREATE TABLE certificate_audit (
  id INT PRIMARY KEY AUTO_INCREMENT,
  certificateId INT NOT NULL,
  action VARCHAR(50) NOT NULL,
  userType ENUM('ORGANIZER', 'PARTICIPANT') NOT NULL,
  userId INT NOT NULL,
  timestamp DATETIME DEFAULT NOW(),
  FOREIGN KEY (certificateId) REFERENCES certificate(id)
);
```

## Related Files

- `/src/app/api/participants/contestants/[id]/generate-certificate/route.ts` - Participant API
- `/src/app/api/certificates/create-non-contestant/route.ts` - Organizer API
- `/database-migration-certificate-createdby-nullable.sql` - Schema change
- `/CONTESTANT_CERT_FIX.md` - Technical fix documentation

## Summary

The nullable `createdBy` approach provides a clean separation between:
- **Organizer-created certificates**: Tracked via `user` table FK
- **Participant-created certificates**: Indicated by `createdBy IS NULL`

This respects the principle that **participants should be able to handle operations within their contingent scope** while maintaining proper audit trails and database integrity.
